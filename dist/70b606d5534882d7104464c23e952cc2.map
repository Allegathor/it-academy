{"version":3,"sources":["../scripts/word_ladder.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"70b606d5534882d7104464c23e952cc2.map","sourcesContent":["/* Graph type */\n\nvar Graph = function() {\n\tthis.vertices = {};\n}\n\nvar GraphNode = function(val) {\n\tthis.val = val;\n\tthis.edges = {};\n}\n\nGraph.prototype.addVertex = function(val) {\n\tif(!this.vertices[val]) {\n\t\tthis.vertices[val] = new GraphNode(val);\n\t}\n}\n\nGraph.prototype.addVertices = function(values) {\n\tfor(var i = 0; i < values.length; i++) {\n\t\tif(!this.vertices[values[i]]) {\n\t\t\tthis.vertices[values[i]] = new GraphNode(values[i]);\n\t\t}\n\t}\n}\n\nGraph.prototype.removeVertex = function(val) {\n\tif(this.vertices[val]) {\n\t\tdelete this.vertices[val];\n\n\t\tfor (key in this.vertices) {\n\t\t\tif (this.vertices[key].edges[val]) {\n\t\t\t\tdelete this.vertices[key].edges[val];\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nGraph.prototype.getVertex = function(val) {\n\treturn this.vertices[val];\n}\n\nGraph.prototype.addEdge = function(start, end) {\n\tif(this.vertices[start] && this.vertices[end]) {\n\t\tthis.vertices[start].edges[end] = true;\n\t\tthis.vertices[end].edges[start] = true;\n\t}\n}\n\nGraph.prototype.removeEdge = function(start, end) {\n\tif(this.vertices[start] && this.vertices[end]) {\n\n\t\tif(this.vertices[start].edges[end]) {\n\t\t\tdelete this.vertices[start].edges[end];\n\t\t}\n\n\t}\n}\n\nGraph.prototype.getEdge = function(start, end) {\n\treturn this.vertices[start].edges[end] || null;\n}\n\nGraph.prototype.getNeighbors = function(val) {\n\treturn this.vertices[val] ? this.vertices[val].edges : null;\n}\n\nvar t1 = ['ТАРА','ЛИПА','ТУРА','ЛУЖА','ПАРК','ЛОЖЬ','ЛУПА','ПЛОТ','МУРА','ПАУК','ПАУТ','ПЛУТ','ЛОЖА','СЛОТ','ПАРА','МУХА','СЛОН','ЛИСА','ЛОСЬ'];\n\n/**\n * Builds a graph based on an array of words\n * @param  {String[]} words Function must accept an array of strings for further work\n * @return {Object}      Return an undirected graph\n */\nvar buildGraph = function(words) {\n\tvar dict = {};\n\tvar wordsGraph = new Graph();\n\twordsGraph.addVertices(words);\n\n\tvar word;\n\tvar bucket;\n\n\tfor(var i = 0; i < words.length; i++) {\n\t\tvar word = words[i];\n\n\t\tfor(var n = 0; n < word.length; n++) {\n\t\t\tvar chars = word.split('');\n\t\t\tchars.splice(n, 1, '_');\n\t\t\tvar bucket = chars.join('');\n\n\t\t\tif(bucket in dict) {\n\t\t\t\tdict[bucket].push(word);\n\t\t\t} else {\n\t\t\t\tdict[bucket] = [word];\n\t\t\t}\n\t\t}\n\n\t}\n\n\tfor(var b in dict) {\n\t\tfor(var i = 0; i < b.length - 1; i++) {\n\t\t\tif(b.length > 1) {\n\t\t\t\tvar word1 = dict[b][i];\n\n\t\t\t\tfor(var j = i + 1; j < b.length; j++) {\n\t\t\t\tvar word2 = dict[b][j];\n\t\t\t\t\tif(word1 !== word2)\n\t\t\t\t\t\twordsGraph.addEdge(word1, word2);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn wordsGraph;\n}\n\n/**\n * Creates a bfsTree-like object\n *\n * @param {Object} g     Must accept a graph\n * @param {String} start Starting point(word)\n *\n * @return {Object} Object that contains nodes and their predecessors\n */\nvar bfsTree = function(g, start) {\n\tvar preds = {}; // Key\n\tvar visited = {};\n\tpreds[start] = null;\n\tvar verticesQueue = [];\n\tverticesQueue.push(start);\n\n\twhile(verticesQueue.length > 0) {\n\t\tvar currentVert = verticesQueue.shift();\n\n\t\tfor(var nbr in g.getNeighbors(currentVert)) {\n\t\t\tif( !visited[nbr] ) {\n\t\t\t\tpreds[nbr] = currentVert;\n\t\t\t\tverticesQueue.push(nbr);\n\t\t\t\tvisited[nbr] = 'f'; // would be visited in future\n\t\t\t}\n\t\t}\n\n\t\tvisited[currentVert] = 'v'; // visited\n\t}\n\treturn preds;\n}\n\nvar normalizeWords = function(words) {\n\tvar wordUp;\n\tvar normalized = words.map(function(word, i) {\n\t\twordUp = word.toLowerCase();\n\t\treturn wordUp;\n\t});\n\n\treturn normalized;\n}\n\n\n/**\n * Creates a word ladder\n *\n * @param {String[]} dict  Dictionary of words\n * @param {String} start\tStarting word\n * @param {String} end   Ending word\n *\n * @return {String} Ladder is the shortest path from the start to the end of the tree\n */\nvar buildLadder = function(dict, start, end) {\n\tvar words = normalizeWords(dict);\n\tvar graph = buildGraph(words);\n\tvar searchTree = bfsTree(graph, start);\n\tvar word = end;\n\tvar words = [];\n\n\tdo {\n\n\t\tif(word === start){\n\t\t\twords.unshift(word);\n\t\t\tbreak;\n\t\t}\n\t\twords.unshift(word);\n\t\tword = searchTree[word];\n\n\t} while(word !== null)\n\n\treturn words.join('-');\n}\n\nconsole.log(buildLadder(t1, 'муха', 'слон'));\nconsole.log(buildLadder(t1, 'лиса', 'лось'));\n"]}